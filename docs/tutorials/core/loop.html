<html>
<body>
<p>
<a href="https://github.com/laforge49/JActor2#readme">JActor2</a> &gt; <a href="../../index.html">Docs</a> &gt; <a href="../index.html">Tutorials</a> &gt; <a href="index.html">Core</a> &gt; Loop
</p>
<h1>Loop - Asynchronous Loops</h1>
<p>
Asynchronous loops have a unique form because a callback is needed to receive the results of each iteration.
But it is all about the callback or, in the case of JActor2, the anonymous AsyncResponseProcessor.
The <a href="Loop.java">Loop</a> class is a good example. It prints the numbers from 1 to 10.
</p>
<pre>
import org.agilewiki.jactor2.core.blades.BladeBase;
import org.agilewiki.jactor2.core.blades.misc.Printer;
import org.agilewiki.jactor2.core.facilities.Facility;
import org.agilewiki.jactor2.core.messages.AsyncRequest;
import org.agilewiki.jactor2.core.messages.AsyncResponseProcessor;
import org.agilewiki.jactor2.core.messages.SyncRequest;
import org.agilewiki.jactor2.core.reactors.NonBlockingReactor;
import org.agilewiki.jactor2.core.reactors.Reactor;

public class Loop extends BladeBase {
    private final Printer printer;

    public Loop(final Reactor _reactor, final Printer _printer) throws Exception {
        initialize(_reactor);
        printer = _printer;
    }

    public AsyncRequest&lt;Void&gt; loopAReq(final long _count) {
        return new AsyncBladeRequest&lt;Void&gt;() {
            final AsyncResponseProcessor&lt;Void&gt; dis = this;
            long i = 0;

            final AsyncResponseProcessor&lt;Void&gt; printCountResponseProcessor = 
                    new AsyncResponseProcessor&lt;Void&gt;() {

                @Override
                public void processAsyncResponse(final Void _response) throws Exception {
                    iterate();
                }
            };

            @Override
            protected void processAsyncRequest() throws Exception {
                iterate();
            }
            
            public void iterate() throws Exception {
                if (i >= _count) {
                    dis.processAsyncResponse(null);
                    return;
                }
                i++;
                SyncRequest&lt;Void&gt; printCount = printer.printlnSReq(String.valueOf(i));
                send(printCount, printCountResponseProcessor);
            }
        };
    }
    
    public static void main(final String[] _args) throws Exception {
        Facility facility = new Facility();
        try {
            Printer printer = Printer.stdoutAReq(facility).call();
            Loop loop = new Loop(
                new NonBlockingReactor(facility),
                printer);
            AsyncRequest&lt;Void&gt; loopAReq = loop.loopAReq(10L);
            loopAReq.call();
        } finally {
            facility.close();
        }
    }
}
</pre>
<h3>
Requests are Not Reusable
</h3>
<pre>
            long i = 0;
</pre>
<p>
The index variable i is a member of the anonymous AsyncBladeRequest, rather than being a member of the Loop blade.
And because requests are not reusable, the state of each request is completely isolated from the state of
all other requests. Intermediate state should be kept as part of the request state, not as part of the blade state.
</p>
<p>
One exception to this rule is when performing I/O, where intermediate state can not be isolated from different
requests. This is why blades which perform I/O must use an IsolationReactor, which only allows one request to
be processed at a time.
</p>
<h3>
processAsyncRequest
</h3>
<pre>
            @Override
            protected void processAsyncRequest() throws Exception {
                iterate();
            }
</pre>
<p>
The processAsyncRequest method is called to process the loop request sent to this blade.
This method then begins the iteration through the numbers to be printed.
</p>
<h3>
iterate
</h3>
<pre>
            public void iterate() throws Exception {
                if (i >= _count) {
                    dis.processAsyncResponse(null);
                    return;
                }
                i++;
                SyncRequest&lt;Void&gt; printCount = printer.printlnSReq(String.valueOf(i));
                send(printCount, printCountResponseProcessor);
            }
</pre>
<p>
The iterate method performs the actual loop.
First the index variable, i, is compared with count.
And if no further iterations are needed, the loop request completes by passing back a null result.
Otherwise i is incremented and a println request is sent.
And the printCountResponseProcessor is used as a callback to process the response from the send.
</p>
<h3>
printCountResponseProcessor
</h3>
<pre>
            final AsyncResponseProcessor&lt;Void&gt; printCountResponseProcessor = 
                    new AsyncResponseProcessor&lt;Void&gt;() {

                @Override
                public void processAsyncResponse(final Void _response) throws Exception {
                    iterate();
                }
            };
</pre>
<p>
The printCountResponseProcessor is used to process the response from a println request sent to the Printer blade.
The response is null and does not actually require any processing, but the receipt of
the response triggers the next iteration of the loop, if needed.
</p>
</body>
</html>
