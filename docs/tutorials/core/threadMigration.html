<html>
<body>
<p>
<a href="https://github.com/laforge49/JActor2#readme">JActor2</a> &gt; <a href="../../index.html">Docs</a> &gt; <a href="../index.html">Tutorials</a> &gt; <a href="index.html">Core</a> &gt; Thread Migration
</p>
<h1>Thread Migration</h1>
<p>
A thread is allocated from a Facility and 
assigned to a Reactor when an idle Reactor
receives a message. 
And a thread is released from a Reactor when that Reactor
becomes idle.
But threads can also migrate from one Reactor to another when a message is sent,
with a new thread assigned to the original Reactor if needed.
Thread migration is significantly faster than passing messages between threads,
as the data does not need to be loaded into another thread's memory cache.
</p>
<p>
The Request.send method uses thread migration whenever possible, for both requests
and responses. This is illustrated by the
<a href="ThreadMigration.java">ThreadMigration</a>
program:
</p>
<pre>
import org.agilewiki.jactor2.core.blades.*;
import org.agilewiki.jactor2.core.facilities.*;
import org.agilewiki.jactor2.core.messages.*;
import org.agilewiki.jactor2.core.reactors.*;

public class ThreadMigration extends BladeBase {
    public static void main(final String[] _args) 
            throws Exception {
        Plant plant = new Plant();
        try {
            System.out.println("\n           main thread: " + 
                Thread.currentThread());
            Reactor reactor = 
                new NonBlockingReactor(plant);
            ThreadMigration threadMigration = 
                new ThreadMigration(reactor);
            threadMigration.startAReq().call();
        } finally {
            plant.close();
        }
    }
    
    public ThreadMigration(final Reactor _reactor) 
            throws Exception {
        initialize(_reactor);
    }
    
    public AsyncRequest&lt;Void&gt; startAReq() {
        return new AsyncBladeRequest&lt;Void&gt;() {
            @Override
            protected void processAsyncRequest() 
                    throws Exception {
                System.out.println("ThreadMigration thread: " + Thread.currentThread());
                Reactor myReactor = getReactor();
                Facility myModuleContext = myReactor.getFacility();
                Reactor subReactor = 
                    new NonBlockingReactor(myModuleContext);
                SubActor subActor = new SubActor(subReactor);
                subActor.doAReq("         signal").signal();
                send(subActor.doAReq("           send"), this);
            }
        };
    }
}

class SubActor extends BladeBase {
    public SubActor(final Reactor _reactor) 
            throws Exception {
        initialize(_reactor);
    }
    
    public AsyncRequest&lt;Void&gt; doAReq(final String _label) {
        return new AsyncBladeRequest&lt;Void&gt;() {
            @Override
            protected void processAsyncRequest() 
                    throws Exception {
                System.out.println(_label + " thread: " + 
                    Thread.currentThread());
                processAsyncResponse(null);
            }
        };
    }
}
</pre>
<p>
And here is the output from a test run:
</p>
<pre>
core>test.bat ThreadMigration

           main thread: Thread[main,5,main]
ThreadMigration thread: Thread[Thread-0,5,main]
         signal thread: Thread[Thread-1,5,main]
           send thread: Thread[Thread-0,5,main]

core>
</pre>
<p>
What this shows is that when 
<a href="../../api/org/agilewiki/jactor2/core/messages/RequestBase.html#signal()">signal</a>
or
<a href="../../api/org/agilewiki/jactor2/core/messages/RequestBase.html#call()">call</a>
methods are used, the request is passed to a new thread. But when the
<a href="../../api/org/agilewiki/jactor2/core/messages/RequestBase.html#send(org.agilewiki.jactor2.core.reactors.Reactor, org.agilewiki.jactor2.core.messages.AsyncResponseProcessor)">send</a>
method is used, the thread migrates with the message.
</p>
</body>
</html>
